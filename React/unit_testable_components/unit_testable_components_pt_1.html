<style>
    blockquote {
        font-size: 16px;
    }
</style>

<body>
    <h2>
        Unit testable components pt.1: Overview
    </h2>
    <section>
        <h3>
            Bad tests are worse than no tests
        </h3>
        <blockquote>
            This code should be changed or refactored, but that would mean I have to update my tests...
        </blockquote>
        <p>
            Testing UI behavior is really hard, and you can get lulled into writing sloppy tests. Sloppy tests are
            unmaintainable and encourage "behavior locking". It's a problem that only grows as time goes on.
        </p>
    </section>
    <section>
        <h3>
            Testing React components is hard
        </h3>
        <p>
            Frontend testing requires, in one form or another, a mocked DOM, which is a beast in its own rite. Your
            tests can't be run like a basic function, because the true environment is the browser. Which is what
            <a href="https://airbnb.io/enzyme/" target="_blank">
                enzyme
            </a>
            was created for. It's a mandatory supplement to
            <a href="https://jestjs.io/" target="_blank"></a>
                jest
            </a>
            for component testing.
        </p>
    </section>
    <section>
        <h3>
            Component design matters a lot more than you think
        </h3>
        <blockquote>
            Well designed components are easy to test
        </blockquote>
        <p>
            Spaghetti code is easy to write, but hard to test and maintain. Large components also hurt performance, for
            reasons that can be dove into on another day. Here are the qualities that I value when I design components.
        </p>
        <ul>
            <li>
                Small components that represent a singular idea
            </li>
            <li>
                Few or no props passed in from parent component (flux implementation needed)
            </li>
            <li>
                Minimal business logic
            </li>
        </ul>
    </section>
    <section>
        <h3>
            When you do things the right way, everything just "falls right into place"
        </h3>
        <p>
            These principles that I value make code clean, maintainable, and implies separation of concerns (which
            vanilla React does a bad job of). Deep dependencies between UI elements and their resulting behavior inside a
            component is the pain point when it comes to testing. It is advantageous to minimize it.
        </p>
    </section>
    <section>
        <h3>
            Redux gives us an ecosystem to create separation of concerns
        </h3>
        <p>
            Redux is its own data flow ecosystem. Its algorithmic operations have nothing to do with the DOM. The only job of flux is to feed data to components, making it the perfect place to abstract out complex behavior. The answer is 
        </p>
    </section>
    <section>
        <h3>
            Testing advantages of abstracting out business logic
        </h3>
        <p>
            Component tests become less complex to test.
        </p>
        <ul>
            <li>
                Very few mocked functions (one or two, at most)
            </li>
            <li>
                No spies
            </li>
            <li>
                No value assertions of actions or api calls (except for local state and render logic)
            </li>
            <li>
                Only render logic needs to be asserted
            </li>
        </ul>
    </section>
    <section>
        <p>
            Starting to sound pretty nice, right?
            Well, sit tight. I'll go indepth in part 2.
        </p>
    </section>
</body>